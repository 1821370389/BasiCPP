# 设计模式

一套被广泛使用广泛知晓的可靠的模板代码

## 设计模式的原则

1. 开放封闭原则
   对扩展开发，对修改封闭
2. 依赖倒置原则
   不要对具体的子类依赖，要依赖抽象类
3. 接口隔离原则
   不依赖的接口不要放在抽象类中
   一个类另外一个类的依赖要建立在最小的接口上
4. 里氏替换原则
   用基类的地方，一定能用子类替换
5. 单一职责原则
   一个类只负责一个功能
6. 迪米特原则
   减少类和类之间的耦合

## 分类

1. 创建型模式：思考构建对象的过程
2. 构造型模式：思考类和类之间的关系
3. 行为型模式：思考类和类的协同工作

### 创建型模式

1. **单例**
   一个类只能创建一个

   * 懒汉式：对象在需要时创建，线程不安全，可以用锁解决
   * 饿汉式：对象在初始化时创建，线程安全，但不灵活
   * 静态式：参见 StdMtsql.cpp, 安全，灵活，但不能手动释放
2. **工厂**
   **简单工厂**： 参见 simpleFactory.cpp
   组成：

   * 抽象产品(基类)
   * 具体产品(子类)
   * 工厂类

   优点：
   将产品指针和产品对象解耦
   缺点：
   增加新的产需要修改工厂类，随着产品增多，工厂类会变得越累越臃肿

   **工厂方法**：把工厂类变成抽象类    参见：`FactoryMem.cpp`

   组成：

   * 抽象产品
   * 具体产品
   * 抽象工厂
   * 具体工厂

   优点：

   * 将产品指针和产品对象解耦
   * 增加新的产品和工厂都不需要修改原类
     缺点：
   * 类的数量变多

   **抽象工厂**：生成不同产品族的同一类产品    参见：`virtualFactory.cpp`

   优点：

   * 减少工厂类的数量
     缺点：
   * 增加新产品需要修改工厂类
3. **建造者模式**：构建复杂对象    参见：`construuctor.cpp`
   优点：

   * 将复杂的产品只恨和构建的过程进行解耦

   缺点：

   * 类变多，结构变复杂
4. **原型模式(克隆模式)**：复制一个原对象    参见`clone.cpp`
   使用情况：如何快速构建对象

### 结构型模式

1. 适配器模式

   * 类适配器 参见：`classAdapter.cpp`
     使用多继承来实现
   * 对象适配器 参见：`ObjectAdapter.cpp`
     使用组合加继承来实现
2. 装饰模式  参见：`decratr.cpp`
   在不修改原类的基础上，添加新的功能
   组成：

   * 抽象产品
   * 具体产品
   * 抽象装饰
   * 具体装饰

   优点：

   * 产品和装饰扩展不需要修改原类

   缺点：

   * 类变多
   * 结构复杂，不易读
3. 代理模式    参见：`proxy.cpp`
   保护被代理类，降低被代理类和其他类的耦合程度(优点)
   缺点：

   * 被代理类修改，代理就要修改
4. 桥接模式 参见：`bridage.cpp`
   将一个事物的变换拆解为两个维度，再将两个维度组合起来
   优点：

   * 显著的提高代码的复用性，将复杂类在两个维度上进行解耦

   缺点：

   * 类变多，结构变复杂
5. 享元模式 参见：`FlyWeight.cpp`
   共享对象，
   对象中共性的部分称为内部状态
   非共性的部分成为外部状态
   优点：

   * 减少对象创建，减少内存，提高程序效率

   缺点：

   * 可扩展性较差
6. 外观模式 参见：`facade.cpp`
   联合多个不相干的类，简化接口
   优点：

   * 简化对外接口

   缺点：

   * 加入新的模块一定会修改外观类

### 行为型模式

1. 模板方法模式 参见：`Templatemethod.cpp`
   定义一套工作流程，具体的实现由子类实现
   优点：

   * 易于扩展，同时保证了接口的统一

   缺点：

   * 类变多，接口变复杂

   模板方法模式 和 外观模式 有什么区别？

   * 外观模式：模块的功能定了，工作方式(状态)没定
   * 模板方法模式：工作的流程定了， 工作内容没定
2. 策略模式 参见：`strategy.cpp`
   解决一个问题有多种方式时
   优点：

   * 能将接口不同变为对象不同，增强了扩展性

   缺点：

   * 类变多，接口变复杂
3. **观察者模式**  参见：`observer.cpp` `connection.cpp`
   建立一对多的关系，当一产生变化，多给予反馈
4. 中介者模式 参见 `Mediator.cpp`
   构建一个类去将两个类连接起来进行通信
   优点：

   * 类和类的通讯进行解耦

   代理模式和中介模式的区别：

   * 代理是一对多 中介是两大类间多对多

   桥接和中介：

   * 中介是两个类间的通讯，桥接是把一个类拆成了两部分提高复用率
5. 责任链模式 参见 `responsibility.cpp`
   能处理请求的类自称一条责任链条
   优点：

   * 将请求和客户端之间解耦
   
   缺点：

   * 当链条逻辑改变时一定会进行修改

