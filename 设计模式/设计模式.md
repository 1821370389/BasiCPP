# 设计模式

一套被广泛使用广泛知晓的可靠的模板代码

## 设计模式的原则

1. 开放封闭原则
   对扩展开发，对修改封闭
2. 依赖倒置原则
   不要对具体的子类依赖，要依赖抽象类
3. 接口隔离原则
   不依赖的接口不要放在抽象类中
   一个类另外一个类的依赖要建立在最小的接口上
4. 里氏替换原则
   用基类的地方，一定能用子类替换
5. 单一职责原则
   一个类只负责一个功能
6. 迪米特原则
   减少类和类之间的耦合

## 分类

1. 创建型模式：思考构建对象的过程
2. 构造型模式：思考类和类之间的关系
3. 行为型模式：思考类和类的协同工作

### 创建型模式

1. **单例**
   一个类只能创建一个

   * 懒汉式：对象在需要时创建，线程不安全，可以用锁解决
   * 饿汉式：对象在初始化时创建，线程安全，但不灵活
   * 静态式：参见 StdMtsql.cpp, 安全，灵活，但不能手动释放
2. **工厂**
   **简单工厂**： 参见 simpleFactory.cpp
   组成：

   * 抽象产品(基类)
   * 具体产品(子类)
   * 工厂类

   优点：
   将产品指针和产品对象解耦
   缺点：
   增加新的产需要修改工厂类，随着产品增多，工厂类会变得越累越臃肿

   **工厂方法**：把工厂类变成抽象类    参见：`FactoryMem.cpp`

   组成：

   * 抽象产品
   * 具体产品
   * 抽象工厂
   * 具体工厂

   优点：

   * 将产品指针和产品对象解耦
   * 增加新的产品和工厂都不需要修改原类
     缺点：
   * 类的数量变多

   **抽象工厂**：生成不同产品族的同一类产品    参见：`virtualFactory.cpp`

   优点：

   * 减少工厂类的数量
     缺点：
   * 增加新产品需要修改工厂类
3. **建造者模式**：构建复杂对象    参见：`construuctor.cpp`
   优点：

   * 将复杂的产品只恨和构建的过程进行解耦

   缺点：

   * 类变多，结构变复杂
4. **原型模式(克隆模式)**：复制一个原对象    参见`clone.cpp`
   使用情况：如何快速构建对象

### 结构型模式

1. 适配器模式

   * 类适配器 参见：`classAdapter.cpp`
     使用多继承来实现
   * 对象适配器 参见：`ObjectAdapter.cpp`
     使用组合加继承来实现
2. 装饰模式  参见：`decratr.cpp`
   在不修改原类的基础上，添加新的功能
   组成：

   * 抽象产品
   * 具体产品
   * 抽象装饰
   * 具体装饰

   优点：

   * 产品和装饰扩展不需要修改原类

   缺点：

   * 类变多
   * 结构复杂，不易读
3. 代理模式    参见：`proxy.cpp`
   保护被代理类，降低被代理类和其他类的耦合程度(优点)
   缺点：

   * 被代理类修改，代理就要修改
